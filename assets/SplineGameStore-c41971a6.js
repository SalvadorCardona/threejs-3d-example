import{V as G,r as n,u as Me,n as we,b as q,_ as ie,D as Pe,o as ce,p as ae,q as Ee,s as Re,t as je,e as We}from"./index-c7e050ab.js";const D=new G,Q=new G,Oe=new G;function Ce(t,e,o){const r=D.setFromMatrixPosition(t.matrixWorld);r.project(e);const s=o.width/2,u=o.height/2;return[r.x*s+s,-(r.y*u)+u]}function He(t,e){const o=D.setFromMatrixPosition(t.matrixWorld),r=Q.setFromMatrixPosition(e.matrixWorld),s=o.sub(r),u=e.getWorldDirection(Oe);return s.angleTo(u)>Math.PI/2}function Ae(t,e,o,r){const s=D.setFromMatrixPosition(t.matrixWorld),u=s.clone();u.project(e),o.setFromCamera(u,e);const l=o.intersectObjects(r,!0);if(l.length){const a=l[0].distance;return s.distanceTo(o.ray.origin)<a}return!0}function Te(t,e){if(e instanceof ce)return e.zoom;if(e instanceof ae){const o=D.setFromMatrixPosition(t.matrixWorld),r=Q.setFromMatrixPosition(e.matrixWorld),s=e.fov*Math.PI/180,u=o.distanceTo(r);return 1/(2*Math.tan(s/2)*u)}else return 1}function $e(t,e,o){if(e instanceof ae||e instanceof ce){const r=D.setFromMatrixPosition(t.matrixWorld),s=Q.setFromMatrixPosition(e.matrixWorld),u=r.distanceTo(s),l=(o[1]-o[0])/(e.far-e.near),a=o[1]-l*e.far;return Math.round(l*u+a)}}const _=t=>Math.abs(t)<1e-10?0:t;function ue(t,e,o=""){let r="matrix3d(";for(let s=0;s!==16;s++)r+=_(e[s]*t.elements[s])+(s!==15?",":")");return o+r}const ke=(t=>e=>ue(e,t))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),De=(t=>(e,o)=>ue(e,t(o),"translate(-50%,-50%)"))(t=>[1/t,1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1]);function ze(t){return t&&typeof t=="object"&&"current"in t}const Ie=n.forwardRef(({children:t,eps:e=.001,style:o,className:r,prepend:s,center:u,fullscreen:l,portal:a,distanceFactor:c,sprite:f=!1,transform:d=!1,occlude:i,onOcclude:v,castShadow:h,receiveShadow:x,material:b,geometry:y,zIndexRange:w=[16777271,0],calculatePosition:j=Ce,as:z="div",wrapperClass:I,pointerEvents:U="auto",...E},J)=>{const{gl:X,camera:p,scene:Y,size:S,raycaster:fe,events:de,viewport:me}=Me(),[g]=n.useState(()=>document.createElement(z)),N=n.useRef(),P=n.useRef(null),ee=n.useRef(0),F=n.useRef([0,0]),$=n.useRef(null),K=n.useRef(null),A=(a==null?void 0:a.current)||de.connected||X.domElement.parentNode,W=n.useRef(null),L=n.useRef(!1),V=n.useMemo(()=>i&&i!=="blending"||Array.isArray(i)&&i.length&&ze(i[0]),[i]);n.useLayoutEffect(()=>{const M=X.domElement;i&&i==="blending"?(M.style.zIndex=`${Math.floor(w[0]/2)}`,M.style.position="absolute",M.style.pointerEvents="none"):(M.style.zIndex=null,M.style.position=null,M.style.pointerEvents=null)},[i]),n.useLayoutEffect(()=>{if(P.current){const M=N.current=we(g);if(Y.updateMatrixWorld(),d)g.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const m=j(P.current,p,S);g.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${m[0]}px,${m[1]}px,0);transform-origin:0 0;`}return A&&(s?A.prepend(g):A.appendChild(g)),()=>{A&&A.removeChild(g),M.unmount()}}},[A,d]),n.useLayoutEffect(()=>{I&&(g.className=I)},[I]);const te=n.useMemo(()=>d?{position:"absolute",top:0,left:0,width:S.width,height:S.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:u?"translate3d(-50%,-50%,0)":"none",...l&&{top:-S.height/2,left:-S.width/2,width:S.width,height:S.height},...o},[o,u,l,S,d]),he=n.useMemo(()=>({position:"absolute",pointerEvents:U}),[U]);n.useLayoutEffect(()=>{if(L.current=!1,d){var M;(M=N.current)==null||M.render(n.createElement("div",{ref:$,style:te},n.createElement("div",{ref:K,style:he},n.createElement("div",{ref:J,className:r,style:o,children:t}))))}else{var m;(m=N.current)==null||m.render(n.createElement("div",{ref:J,style:te,className:r,children:t}))}});const T=n.useRef(!0);q(M=>{if(P.current){p.updateMatrixWorld(),P.current.updateWorldMatrix(!0,!1);const m=d?F.current:j(P.current,p,S);if(d||Math.abs(ee.current-p.zoom)>e||Math.abs(F.current[0]-m[0])>e||Math.abs(F.current[1]-m[1])>e){const O=He(P.current,p);let R=!1;V&&(i!=="blending"?R=[Y]:Array.isArray(i)&&(R=i.map(C=>C.current)));const k=T.current;if(R){const C=Ae(P.current,p,fe,R);T.current=C&&!O}else T.current=!O;k!==T.current&&(v?v(!T.current):g.style.display=T.current?"block":"none");const B=Math.floor(w[0]/2),ve=i?V?[w[0],B]:[B-1,0]:w;if(g.style.zIndex=`${$e(P.current,p,ve)}`,d){const[C,re]=[S.width/2,S.height/2],Z=p.projectionMatrix.elements[5]*re,{isOrthographicCamera:se,top:be,left:xe,bottom:ye,right:pe}=p,ge=ke(p.matrixWorldInverse),Se=se?`scale(${Z})translate(${_(-(pe+xe)/2)}px,${_((be+ye)/2)}px)`:`translateZ(${Z}px)`;let H=P.current.matrixWorld;f&&(H=p.matrixWorldInverse.clone().transpose().copyPosition(H).scale(P.current.scale),H.elements[3]=H.elements[7]=H.elements[11]=0,H.elements[15]=1),g.style.width=S.width+"px",g.style.height=S.height+"px",g.style.perspective=se?"":`${Z}px`,$.current&&K.current&&($.current.style.transform=`${Se}${ge}translate(${C}px,${re}px)`,K.current.style.transform=De(H,1/((c||10)/400)))}else{const C=c===void 0?1:Te(P.current,p)*c;g.style.transform=`translate3d(${m[0]}px,${m[1]}px,0) scale(${C})`}F.current=m,ee.current=p.zoom}}if(!V&&W.current&&!L.current)if(d){if($.current){const m=$.current.children[0];if(m!=null&&m.clientWidth&&m!=null&&m.clientHeight){const{isOrthographicCamera:O}=p;if(O||y)E.scale&&(Array.isArray(E.scale)?E.scale instanceof G?W.current.scale.copy(E.scale.clone().divideScalar(1)):W.current.scale.set(1/E.scale[0],1/E.scale[1],1/E.scale[2]):W.current.scale.setScalar(1/E.scale));else{const R=(c||10)/400,k=m.clientWidth*R,B=m.clientHeight*R;W.current.scale.set(k,B,1)}L.current=!0}}}else{const m=g.children[0];if(m!=null&&m.clientWidth&&m!=null&&m.clientHeight){const O=1/me.factor,R=m.clientWidth*O,k=m.clientHeight*O;W.current.scale.set(R,k,1),L.current=!0}W.current.lookAt(M.camera.position)}});const ne=n.useMemo(()=>({vertexShader:d?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[d]);return n.createElement("group",ie({},E,{ref:P}),i&&!V&&n.createElement("mesh",{castShadow:h,receiveShadow:x,ref:W},y||n.createElement("planeGeometry",null),b||n.createElement("shaderMaterial",{side:Pe,vertexShader:ne.vertexShader,fragmentShader:ne.fragmentShader})))});function Fe(t){let e;const o=new Set,r=(f,d)=>{const i=typeof f=="function"?f(e):f;if(i!==e){const v=e;e=d?i:Object.assign({},e,i),o.forEach(h=>h(e,v))}},s=()=>e,u=(f,d=s,i=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let v=d(e);function h(){const x=d(e);if(!i(v,x)){const b=v;f(v=x,b)}}return o.add(h),()=>o.delete(h)},c={setState:r,getState:s,subscribe:(f,d,i)=>d||i?u(f,d,i):(o.add(f),()=>o.delete(f)),destroy:()=>o.clear()};return e=t(r,s,c),c}const Le=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),oe=Le?n.useEffect:n.useLayoutEffect;function Ve(t){const e=typeof t=="function"?Fe(t):t,o=(r=e.getState,s=Object.is)=>{const[,u]=n.useReducer(y=>y+1,0),l=e.getState(),a=n.useRef(l),c=n.useRef(r),f=n.useRef(s),d=n.useRef(!1),i=n.useRef();i.current===void 0&&(i.current=r(l));let v,h=!1;(a.current!==l||c.current!==r||f.current!==s||d.current)&&(v=r(l),h=!s(i.current,v)),oe(()=>{h&&(i.current=v),a.current=l,c.current=r,f.current=s,d.current=!1});const x=n.useRef(l);oe(()=>{const y=()=>{try{const j=e.getState(),z=c.current(j);f.current(i.current,z)||(a.current=j,i.current=z,u())}catch{d.current=!0,u()}},w=e.subscribe(y);return e.getState()!==x.current&&y(),w},[]);const b=h?v:i.current;return n.useDebugValue(b),b};return Object.assign(o,e),o[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const r=[o,e];return{next(){const s=r.length<=0;return{value:r.shift(),done:s}}}},o}const Be=t=>(e,o,r)=>{const s=r.subscribe;return r.subscribe=(l,a,c)=>{let f=l;if(a){const d=(c==null?void 0:c.equalityFn)||Object.is;let i=l(r.getState());f=v=>{const h=l(v);if(!d(i,h)){const x=i;a(i=h,x)}},c!=null&&c.fireImmediately&&a(i,i)}return s(f)},t(e,o,r)},le=n.createContext(null);function Ne({map:t,children:e,onChange:o,domElement:r}){const s=t.map(c=>c.name+c.keys).join("-"),u=n.useMemo(()=>Ve(Be(()=>t.reduce((c,f)=>({...c,[f.name]:!1}),{}))),[s]),l=n.useMemo(()=>[u.subscribe,u.getState,u],[s]),a=u.setState;return n.useEffect(()=>{const f=t.map(({name:h,keys:x,up:b})=>({keys:x,up:b,fn:y=>{a({[h]:y}),o&&o(h,y,l[1]())}})).reduce((h,{keys:x,fn:b,up:y=!0})=>(x.forEach(w=>h[w]={fn:b,pressed:!1,up:y}),h),{}),d=({key:h,code:x})=>{const b=f[h]||f[x];if(!b)return;const{fn:y,pressed:w,up:j}=b;b.pressed=!0,(j||!w)&&y(!0)},i=({key:h,code:x})=>{const b=f[h]||f[x];if(!b)return;const{fn:y,up:w}=b;b.pressed=!1,w&&y(!1)},v=r||window;return v.addEventListener("keydown",d,{passive:!0}),v.addEventListener("keyup",i,{passive:!0}),()=>{v.removeEventListener("keydown",d),v.removeEventListener("keyup",i)}},[r,s]),n.createElement(le.Provider,{value:l,children:e})}function Ke(t){const[e,o,r]=n.useContext(le);return t?r(t):[e,o]}const Ze=n.forwardRef(function({follow:e=!0,lockX:o=!1,lockY:r=!1,lockZ:s=!1,...u},l){const a=n.useRef();return q(({camera:c})=>{if(!e||!a.current)return;const f=a.current.rotation.clone();c.getWorldQuaternion(a.current.quaternion),o&&(a.current.rotation.x=f.x),r&&(a.current.rotation.y=f.y),s&&(a.current.rotation.z=f.z)}),n.createElement("group",ie({ref:Ee([a,l])},u))});function _e(t,e){const o=n.useRef(),[r]=n.useState(()=>e?e instanceof Re?{current:e}:e:o),[s]=n.useState(()=>new je(void 0));n.useLayoutEffect(()=>void(s._root=r.current),[s,e]);const u=n.useRef({}),[l]=n.useState(()=>{const a={};return t.forEach(c=>Object.defineProperty(a,c.name,{enumerable:!0,get(){if(r.current)return u.current[c.name]||(u.current[c.name]=s.clipAction(c,r.current))},configurable:!0})),{ref:r,clips:t,actions:a,names:t.map(c=>c.name),mixer:s}});return q((a,c)=>s.update(c)),n.useEffect(()=>{const a=r.current;return()=>{u.current={},Object.values(l.actions).forEach(c=>{a&&s.uncacheAction(c,a)})}},[t]),n.useEffect(()=>()=>{s.stopAllAction()},[s]),l}const qe=We(()=>({player:null,moveHandlers:[],move:function(){this.moveHandlers.forEach(t=>t(this))},onMove:function(t){this.moveHandlers.push(t)},foodGivenHandlers:[],foodGiven:function(t){this.foodGivenHandlers.forEach(e=>e(t))},onFoodGiven:function(t){this.foodGivenHandlers.push(t)}}));export{Ze as B,Ie as H,Ne as K,_e as a,Ke as b,qe as u};
